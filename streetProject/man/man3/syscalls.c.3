.TH "Core/Src/syscalls.c" 3 "Thu Dec 15 2022" "street" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Core/Src/syscalls.c \- STM32CubeIDE Minimal System calls file\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <sys/stat\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <signal\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include <sys/times\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fB__io_putchar\fP (int ch) __attribute__((weak))"
.br
.ti -1c
.RI "int \fB__io_getchar\fP (void)"
.br
.ti -1c
.RI "void \fBinitialise_monitor_handles\fP ()"
.br
.ti -1c
.RI "int \fB_getpid\fP (void)"
.br
.ti -1c
.RI "int \fB_kill\fP (int pid, int sig)"
.br
.ti -1c
.RI "void \fB_exit\fP (int status)"
.br
.ti -1c
.RI "\fB__attribute__\fP ((weak))"
.br
.ti -1c
.RI "int \fB_close\fP (int file)"
.br
.ti -1c
.RI "int \fB_fstat\fP (int file, struct stat *st)"
.br
.ti -1c
.RI "int \fB_isatty\fP (int file)"
.br
.ti -1c
.RI "int \fB_lseek\fP (int file, int ptr, int dir)"
.br
.ti -1c
.RI "int \fB_open\fP (char *path, int flags,\&.\&.\&.)"
.br
.ti -1c
.RI "int \fB_wait\fP (int *status)"
.br
.ti -1c
.RI "int \fB_unlink\fP (char *name)"
.br
.ti -1c
.RI "int \fB_times\fP (struct tms *buf)"
.br
.ti -1c
.RI "int \fB_stat\fP (char *file, struct stat *st)"
.br
.ti -1c
.RI "int \fB_link\fP (char *old, char *new)"
.br
.ti -1c
.RI "int \fB_fork\fP (void)"
.br
.ti -1c
.RI "int \fB_execve\fP (char *name, char **argv, char **env)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "char ** \fBenviron\fP = __env"
.br
.in -1c
.SH "Detailed Description"
.PP 
STM32CubeIDE Minimal System calls file\&. 


.PP
\fBAuthor\fP
.RS 4
Auto-generated by STM32CubeIDE 
.PP
.nf
       For more information about which c-functions
       need which of these lowlevel functions
       please consult the Newlib libc-manual

.fi
.PP
 
.RE
.PP
\fBAttention\fP
.RS 4
.RE
.PP
Copyright (c) 2022 STMicroelectronics\&. All rights reserved\&.
.PP
This software is licensed under terms that can be found in the LICENSE file in the root directory of this software component\&. If no LICENSE file comes with this software, it is provided AS-IS\&. 
.PP
Definition in file \fBsyscalls\&.c\fP\&.
.SH "Function Documentation"
.PP 
.SS "__attribute__ ((weak))"

.PP
Definition at line \fB65\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
66 {
67     int DataIdx;
68 
69     for (DataIdx = 0; DataIdx < len; DataIdx++)
70     {
71         *ptr++ = __io_getchar();
72     }
73 
74 return len;
75 }
.fi
.SS "int __io_getchar (void)"

.PP
Definition at line \fB36\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
39                  { 0 };
.fi
.SS "int _close (int file)"

.PP
Definition at line \fB88\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
89 {
90     return -1;
91 }
.fi
.SS "int _execve (char * name, char ** argv, char ** env)"

.PP
Definition at line \fB151\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
152 {
153     errno = ENOMEM;
154     return -1;
155 }
.fi
.SS "void _exit (int status)"

.PP
Definition at line \fB59\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
60 {
61     _kill(status, -1);
62     while (1) {}        /* Make sure we hang here */
63 }
.fi
.SS "int _fork (void)"

.PP
Definition at line \fB145\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
146 {
147     errno = EAGAIN;
148     return -1;
149 }
.fi
.SS "int _fstat (int file, struct stat * st)"

.PP
Definition at line \fB94\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
95 {
96     st->st_mode = S_IFCHR;
97     return 0;
98 }
.fi
.SS "int _getpid (void)"

.PP
Definition at line \fB48\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
49 {
50     return 1;
51 }
.fi
.SS "int _isatty (int file)"

.PP
Definition at line \fB100\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
101 {
102     return 1;
103 }
.fi
.SS "int _kill (int pid, int sig)"

.PP
Definition at line \fB53\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
54 {
55     errno = EINVAL;
56     return -1;
57 }
.fi
.SS "int _link (char * old, char * new)"

.PP
Definition at line \fB139\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
140 {
141     errno = EMLINK;
142     return -1;
143 }
.fi
.SS "int _lseek (int file, int ptr, int dir)"

.PP
Definition at line \fB105\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
106 {
107     return 0;
108 }
.fi
.SS "int _open (char * path, int flags,  \&.\&.\&.)"

.PP
Definition at line \fB110\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
111 {
112     /* Pretend like we always fail */
113     return -1;
114 }
.fi
.SS "int _stat (char * file, struct stat * st)"

.PP
Definition at line \fB133\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
134 {
135     st->st_mode = S_IFCHR;
136     return 0;
137 }
.fi
.SS "int _times (struct tms * buf)"

.PP
Definition at line \fB128\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
129 {
130     return -1;
131 }
.fi
.SS "int _unlink (char * name)"

.PP
Definition at line \fB122\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
123 {
124     errno = ENOENT;
125     return -1;
126 }
.fi
.SS "int _wait (int * status)"

.PP
Definition at line \fB116\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
117 {
118     errno = ECHILD;
119     return -1;
120 }
.fi
.SS "void initialise_monitor_handles ()"

.PP
Definition at line \fB44\fP of file \fBsyscalls\&.c\fP\&.
.PP
.nf
45 {
46 }
.fi
.SH "Variable Documentation"
.PP 
.SS "char** environ = __env"

.PP
Definition at line \fB40\fP of file \fBsyscalls\&.c\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for street from the source code\&.
